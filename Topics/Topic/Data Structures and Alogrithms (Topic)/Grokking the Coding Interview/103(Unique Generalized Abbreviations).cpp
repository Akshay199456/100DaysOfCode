/*
Problem statement:

Given a word, write a function to generate all of its unique generalized abbreviations.

A generalized abbreviation of a word can be generated by replacing each substring of the word with the count of characters in the substring. Take the example of “ab” which has four substrings: “”, “a”, “b”, and “ab”. After replacing these substrings in the actual word by the count of characters, we get all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”.

Note: All contiguous characters should be considered one substring, e.g., we can’t take “a” and “b” as substrings to get “11”; since “a” and “b” are contiguous, we should consider them together as one substring to get an abbreviation “2”.

Example 1:

Input: "BAT"
Output: "BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"
Example 2:

Input: "code"
Output: "code", "cod1", "co1e", "co2", "c1de", "c1d1", "c2e", "c3", "1ode", "1od1", "1o1e", "1o2", 
"2de", "2d1", "3e", "4"
*/

/*
-------------------------    My Approaches:
1. 

    Time complexity: O()
    Space complexity: O()
*/


/*
-------------------------    Other Approaches 
1.

    Time complexity: O()
    Space complexity: O()
*/


/*
-------------------------    Notes
follows the subsets pattern and can be mapped to balanced paranthesis. can follow a similar BFS approach

lets take example 1 mentioned above to generate all unique generalized abbreviations. following a bfs approach, we will abbreviate one character at a time. 
at each step, we have twwo options:
1. abbreviate the current character or
2. add the current character to the output and skip the abbreviation

following these two riles, let's abbreviate BAT:
1. start with an empty word: ""
2. at every step, we will take all the combinations from the prebvious step and apply the two abbreviations rules to the next character
3. take the emppty word from the previous step and add the first character to it. we can either abbreviate the character or add it(by skipping abbreviation). this gives us two new words: _ and B.
4. in the next iteration, lets add the second character. applying the two rules on _ will give us _ _ and 1A. Applyuing the abpove rules to the other combniation B gives us B_ and BA.
5. the next iteration will give us: _ _ _, 2T, 1A_, 1AT, B _ _, B1T, BA_, BAT
6. the final iteration will give us: 3, 2T, 1A1, 1AT, B2, B1T, BA1, BAT


ADditional notes

with subsets, combinations, permutations problem, we can use either DFS or BFS. both work well and are efficient int he same manner in order to 
solve the problem. the key to understand in these problems is to understand how we move from the current level to the next level 
using decisions that are avialble to us. a visual representation of the algorithm can be helpful here in order to understand the possible options you have at each stage.

    Time complexity: O()
    Space complexity: O()
*/



//  My approaches(1)



//  Other Approaches(1)
using namespace std;

#include <iostream>
#include <queue>
#include <string>
#include <vector>

class AbbreviatedWord {
 public:
  string str;
  int start = 0;
  int count = 0;

  AbbreviatedWord(string str, int start, int count) {
    this->str = str;
    this->start = start;
    this->count = count;
  }
};

class GeneralizedAbbreviation {
 public:
  static vector<string> generateGeneralizedAbbreviation(const string &word) {
    int wordLen = word.length();
    vector<string> result;
    queue<AbbreviatedWord> queue;
    queue.push({"", 0, 0});
    while (!queue.empty()) {
      AbbreviatedWord abWord = queue.front();
      queue.pop();
      if (abWord.start == wordLen) {
        if (abWord.count != 0) {
          abWord.str += to_string(abWord.count);
        }
        result.push_back(abWord.str);
      } else {
        // continue abbreviating by incrementing the current abbreviation count
        queue.push({abWord.str, abWord.start + 1, abWord.count + 1});

        // restart abbreviating, append the count and the current character to the string
        if (abWord.count != 0) {
          abWord.str += to_string(abWord.count);
        }
        abWord.str += word[abWord.start];
        queue.push({abWord.str, abWord.start + 1, 0});
      }
    }

    return result;
  }
};

int main(int argc, char *argv[]) {
  vector<string> result = GeneralizedAbbreviation::generateGeneralizedAbbreviation("BAT");
  cout << "Generalized abbreviation are: ";
  for (auto str : result) {
    cout << str << " ";
  }
  cout << endl;

  result = GeneralizedAbbreviation::generateGeneralizedAbbreviation("code");
  cout << "Generalized abbreviation are: ";
  for (auto str : result) {
    cout << str << " ";
  }
  cout << endl;
}


// Other Approaches(2)
using namespace std;

#include <iostream>
#include <string>
#include <vector>

class GeneralizedAbbreviationRecursive {
 public:
  static vector<string> generateGeneralizedAbbreviation(const string &word) {
    vector<string> result;
    string abWord = "";
    generateAbbreviationRecursive(word, abWord, 0, 0, result);
    return result;
  }

 private:
  static void generateAbbreviationRecursive(const string &word, string &abWord, int start,
                                            int count, vector<string> &result) {
    if (start == word.length()) {
      if (count != 0) {
        abWord += to_string(count);
      }
      result.push_back(abWord);
    } else {
      // continue abbreviating by incrementing the current abbreviation count
      string newWord(abWord);
      generateAbbreviationRecursive(word, newWord, start + 1, count + 1, result);

      // restart abbreviating, append the count and the current character to the string
      if (count != 0) {
        abWord += to_string(count);
      }
      abWord += word[start];
      generateAbbreviationRecursive(word, abWord, start + 1, 0, result);
    }
  }
};

int main(int argc, char *argv[]) {
  vector<string> result = GeneralizedAbbreviationRecursive::generateGeneralizedAbbreviation("BAT");
  cout << "Generalized abbreviation are: ";
  for (auto str : result) {
    cout << str << " ";
  }
  cout << endl;

  result = GeneralizedAbbreviationRecursive::generateGeneralizedAbbreviation("code");
  cout << "Generalized abbreviation are: ";
  for (auto str : result) {
    cout << str << " ";
  }
  cout << endl;
}
