/*
Problem statement:

Given a list of n items and their weights, find all sums that can be formed using their weights.

Input
weights: A list of items and their weights.
Output
A list of possible sums using the weights.

Examples
Example 1:
Input:

weights = [1, 3, 3, 5]
Output: [0, 1, 3, 4, 5, 6, 7, 8, 9, 11, 12]

Explanation:

We can form all sums from 0 to 12 except 2 and 10. Here is a short explanation for the sums:

0: use none of the weights
1: use item with weight 1
3: use item with weight 3
4: use weights 1 + 3 = 4
5: use item with weight 5
6: use weights 3 + 3 = 6
7: use weights 1 + 3 + 3 = 7
8: use weights 3 + 5 = 8
9: use weights 1 + 3 + 5 = 9
11: use weights 3 + 3 + 5 = 11
12: use all weights
Constraints
1 <= len(weights) <= 100
1 <= weights[i] <= 100
*/

/*
-------------------------    My Approaches:
1. brute force approach - combinations

    since the problem asks for all sums that can be formed using their weights, one way we can get the sum of all weights is to
    generate all weight combinations first. this then falls into a combination problem where we are generating all possible combinations.
    in order to generate all possible permutations, at each step, we have one of two chocies. we can either add this elemnt to the list from the previous
    step or we can choose not to. doing that for all elements gives us all possible combinations and the sum of each gives us all poissible weight combination sums.

    Time complexity: O(2^n)
    Space complexity: O(n)
*/


/*
-------------------------    Other Approaches 
1.

    Time complexity: O()
    Space complexity: O()
*/


/*
-------------------------    Notes
a brute force method enumerates all possibilites. we start with a toal su, of 0 and process every item by either choosing to nclude it into our sum or not into our sum.
once no more items are left to process, we can include the final su, in a list of sums. additionally, we will store these sums in a set since there can be repeating sums.

by going through every possibility, we are generating all possible subsets, so we guarnatee that we are also generating all possible sums.

since there are n items, two possibilities each and it takes O(1) to compute each possibiility, the final runtime is O(2^n).

the following the space-state tree for this idea using input [1,3,3,5]. each level i of the tree represents a binary decision to include or not include the ith number. for example,
we have two branches in level i=1, the left branch eans not picking the ith item 3 and the right branch means picking it.


    Time complexity: O()
    Space complexity: O()

Top-down dynamic programming

    first, the 'top-down' solution is, basically, the brute force solution but with memoization. we store results that have already been computed and return them once needed.
    but, in precisely what way should be store/represent the data? going back to the idea of dynamic programming, we should consider what is 
    important so far and if any of the information has been recomputed

    memoizatiion, identifying the state
        to memoize, we need to find the duplicate subtrees in the state-space tree

        note that the duplicate subtrees are of the same level for this problem. this isnt a coincide.

        unlike word break and decode ways in the backtracking section, the items in the knapsack problem can only be used once

        consider node a and node b in the tree

        node' B's subtree has leaf values of 3 and 8. And node A's subtree has leaf values of 3,8,6,11. they are clearly not the same subtree.
        this is because the meaning of a node's value is the weigt sum by considering items from 0 to i.

        therefore, the state we need to memoize consists of the level/dpeth of the node and the node value itself. we will use i(sum) to denote this.

        thus, we will store a 2d boolean array memo where memo[i][sum] = true if the (i,sum) pair has already been computed and false otherwise.
        the size of the array is n*total_sum where n is the number of items and total_sum is the weight sum of all items.
        we need a slot for each possoble weight we can make up and all the possible weights are in th range of 0 to total_sum

        since there are n* totalSum states, each state depends on O(1) subproblems and each state takes O(1) to compute and the final runtime is 
        O(n*totalSum)


*/



//  My approaches(1)
#include <algorithm> // copy, sort
#include <iostream> // cin
#include <iterator> // back_inserter, istream_iterator
#include <sstream> // istringstream
#include <string> // getline, string
#include <vector> // vector
#include <algorithm>
#include <unordered_set>

void dfs(std::vector<int> & weights, std::unordered_set<int> & elementSet, int index, int total){
    if(index == weights.size())
        elementSet.emplace(total);
    else{
        // we can choose to add this element to the total
        dfs(weights, elementSet, index+1, total + weights[index]);
        // we can choose to not add this element to the total
        dfs(weights, elementSet, index+1, total);
    }
}


void fillResult(std::unordered_set<int> & elementSet, std::vector<int> & result){
    for(auto it = elementSet.begin(); it!= elementSet.end(); it++){
        result.push_back(*it);
    }
}


std::vector<int> knapsack_weight_only(std::vector<int> weights) {
    // WRITE YOUR BRILLIANT CODE HERE
    std::unordered_set<int> elementSet;
    std::vector<int> result;
    dfs(weights, elementSet, 0, 0);
    // sort result and remove duplicates
    fillResult(elementSet, result);
    return result;
}

template<typename T>
std::vector<T> get_words() {
    std::string line;
    std::getline(std::cin, line);
    std::istringstream ss{line};
    std::vector<T> v;
    std::copy(std::istream_iterator<T>{ss}, std::istream_iterator<T>{}, std::back_inserter(v));
    return v;
}

int main() {
    std::vector<int> weights = get_words<int>();
    std::vector<int> res = knapsack_weight_only(weights);
    std::sort(res.begin(), res.end());
    for (int i = 0; i < res.size(); i++) {
      std::cout << res[i];
      if (i != res.size() - 1) {
        std::cout << " ";
      }
    }
    std::cout << "\n";
}



//  Other Approaches(1)
#include <set> // set

void generate_sums(vector<int> &weights, set<int> &sums, int sum, int n) {
  if (n == 0) {
    sums.insert(sum);
    return;
  }
  generate_sums(weights, sums, sum, n - 1);
  generate_sums(weights, sums, sum + weights[n - 1], n - 1);
}

vector<int> knapsack_weight_only(vector<int> weights) {
  set<int> sums;
  int n = weights.size();
  generate_sums(weights, sums, 0, n);
  vector ans(sums.begin(), sums.end());
  return ans;
}


// Other Approaches(2)
void generate_sums(vector<int> &weights, set<int> &sums, int sum, int n, vector<vector<bool>> &memo) {
  if (memo[n][sum]) {
    return;
  }
  if (n == 0) {
    sums.insert(sum);
    return;
  }
  generate_sums(weights, sums, sum, n - 1, memo);
  generate_sums(weights, sums, sum + weights[n - 1], n - 1, memo);
}
vector<int> knapsack_weight_only(vector<int> weights) {
  set<int> sums;
  int n = weights.size();
  // find total sum of all items
  int total_sum = 0;
  for (int weight : weights) {
    total_sum += weight;
  }
  // initialize memo table to store if result has been calculated
  vector<vector<bool>> memo(n + 1, vector<bool>(total_sum + 1, false));
  generate_sums(weights, sums, 0, n, memo);
  vector ans(sums.begin(), sums.end());
  return ans;
}